## 버블 정렬

- 거품이 물에 떠오르는 모양처럼 정렬이 됨
  - 가장 첫번 쨰로 나오는 알고리즘 , 뒤에서 부터 앞으로 정렬해 나가는 구조
  - 맨 뒷자리에 제일 큰 값을 제일 뒤로 보내고, 제일 큰 값 바로 앞에 두번째로 큰 값을 보냄

- 예시 리스트

```python
[4,3,5,1,2]
```

- 먼저 `[4,3]` 을 비교, `[4]` 가 `[3]` 보다 크기 때문에 자리를 바꿈

```python
[4,3,5,1,2]
[3,4,5,1,2]
```

- 그다음 `[4,5]`를 비교 `[4]`가 `[5]`보다 작기 때문에 바꾸지 않음

```python
[3,4,5,1,2] #no swap
```

- 그다음 `[5,1]`을 비교, `[5]`가 `[1]`보다 크기 때문에 자리를 바꿈

```python
[3,4,1,5,2]
```

- 그다음 `[5,2]`를 비교,`[5]`가 `[2]`보다 크기 때문에 자리를 바꿈

```python
[3,4,1,2,5]
```

이렇게 처음 값부터 계속해서 앞에 값과 비교하면 제일 큰 값을 뒤로 보낼 수 있음

#### 특징

- 거품 정렬은 큰 값을을 뒤엣 부터 하나씩 쌓여 나가기 때문에 후반으로 갈 수록 정렬 범위가 하나씩 줄어듬
- 선택정렬 - 제일 작은 값을 찾아서 맨 앞에 위치시킴 ( 버블정렬과 정반대)

#### 복잡도 분석

- 별도의 추가공간 사용 x , 주어진 배열이 차지하고 있는 공간 내에서 위치만 바꾸기 때문에 0(1)의 공간복잡도를 가짐
- 루프문을 통해 맨 뒤에서 앞까지 모든 인덱스를 접근해야되어 0(n) 시간 소모, 총 0(n^2)

```python
def buble_sort(num):
  for i in range(len(num)-1,0,-1): #num길이 거꾸로 0까지 반복
    for j in range(i): #2중으로 반복
      if num[j] > num[j+1]: #앞에서 부터 큰값을 뒤로 보냄
        num[j],num[j+1]=num[j+1],num[j] #큰값 순서 변경
        #'j' 까지 순차적으로 제일 큰값을 뒤로 보낸뒤
        #'i-1'부터 반복해 맨 뒷 숫자를 제외하고 반복
  print(num)
```

#### 최적화

- 자리 비교가 되지 않는 값들은 패스를 수행해 연산 속도를 높임

```python
def buble_sort(num):
  for i in range(len(num)-1,0,-1):
    swapped =False
    for j in range(i):
      if num[j] > num[j+1]:
        num[j],num[j+1]=num[j+1],num[j]
        swapped =True #변경점을 True 값으로 
    if swapped ==False: #변경점이 없다면 그 뒤에 j반복을 멈춤
      break
  print(num)
```

[참고 사이트](https://www.daleseo.com/sort-bubble/)

#### 추가강의

- 첫번째랑 두번쨰랑 비교해서 두번째 것이 더 작으면 자리를 서로 바꿔준다

  

```python
num = [7,3,2,9,4,5,10,15]
def buble_sort(num):
  for j in range(len(num)): 
    for index in range(j,len(num)): #앞에 제일 작은 값을 부른다
        if num[j] >num[index]:
          num[j],num[index] = num[index],num[j] # 작은 값 제일 앞에 위													치시킴
  return num
[2, 3, 4, 5, 7, 9, 10, 15]
```

